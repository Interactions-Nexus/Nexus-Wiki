<!--
title: 增强合约
description: Nexus 麟社上的增强合约
published: true
date: 2022-12-11T12:41:59.420Z
tags: 
editor: ckeditor
dateCreated: 2022-12-11T10:36:02.051Z
-->

<h1>📃 增强合约</h1>
<p>Nexus 麟社虚拟机 (NVM) 是一种 <code><strong>state machine</strong></code>状态机，作为一个单一实体存在，由数百个连接的 Nexus 麟社节点维护。</p>
<p>Nexus 麟社软件堆栈的存在仅仅是为了保持这个特殊状态机的连续、不间断和不可变的运行； 它是所有 Nexus 麟社账户和增强合约所在的环境。 在链中的任何给定点，Nexus 麟社都有一个且只有一个 <code><strong>canonical</strong></code> 规范状态，而 NVM 麟社虚拟机定义了从一个区块到另一个区块计算新有效状态的规则。</p>
<p>尽管所有智能合约平台都是状态机，但对可扩展性以适应现实世界使用的痴迷最终造就了 NVM 的独特架构。 为了轻松区分更好的架构，必须将 Nexus 麟社上的合约命名为高级合约。 下面我们将解开架构。</p>
<h2>NVM 麟社虚拟机架构</h2>
<p>NVM 麟社虚拟机被设计为“64 位元”、“register based“ 基于寄存器； 选择此设计是因为它与 CPU 中央处理器的 64 位元匹配并模仿 CPU 中央处理器缓存寄存器。</p>
<p>与 EVM 相比，这种设计使 NVM 麟社虚拟机非常快，因为它是为当今的处理器设计的。 用数字表示，EVM 需要 170 万纳秒/指令，NVM 麟社虚拟机只需要 33 纳秒/指令。 由于 EVM 在 64 位元 CPU 上的 256 位长度及其过时的堆栈设计，EVM 处于一个巨大的劣势，因为它需要 4 个周期来完成一条指令。</p>
<p>NVM 麟社虚拟机有意设计为不图灵完备，这一决定也源于 Nexus 麟社是一个 <code><strong>Verification</strong></code> 验证引擎这一事实。 这种设计有一个巨大的优势，那就是免费的简单交易，而 EVM 需要 Gas 来控制由于糟糕的合约代码而导致的计算请求，这可能会使网络陷入停顿。 使用 NVM 麟社虚拟机设计，增强合约将具有可预测的费用，这些费用将在合约执行前就可以计算出来。</p>
<p>Nexus 麟社将有不同类型的合约，对于更高级别的 API，将提供模板，用户可以从下拉列表中选择。 对于高级用户，增强合同将使他们能够使用他们选择的领域特定语言的合约。 扩展合约将在以后提供。 有关详细信息，请参阅 &nbsp;<a href="https://nexus.io/roadmap">roadmap</a> 路线图。</p>
<h2>Operations &amp; Register Layers 操作和寄存器层</h2>
<p>简而言之，合约是对数据执行特定类型指令的请求，该指令会导致数据发生变化。 在 Nexus 麟社软件堆栈中，<code>Operations layer</code>&nbsp;操作层包含提供寄存器上下文的指令或操作，并定义更复杂的合约逻辑，<code>Register layer</code>&nbsp;寄存器层是数据层。 合约是一个包含以下内容的对象：寄存器预状态（从寄存器层向上传递的正在操作的寄存器），基元操作（每个合约只有一个基元操作）和一组条件（任何数量 条件操作）。</p>
<h3>Primitive Operations 基元操作</h3>
<p>操作层的当前迭代包含 16 个基元操作和 54 个条件操作和类型。 基元操作可以最好地描述为在寄存器上发生的操作，例如：WRITE、DEBIT、TRANSFER、APPEND 等。这些操作本身会导致寄存器以某种方式或形式更改其状态，包括从一个签名开始的移动 链到另一个。</p>
<h3>Conditional Contracts 条件合约</h3>
<p>条件合约是参与方之间的协议，概述了完成交易必须满足的一组要求。 它们是允许用户相互参与的基石，例如合约到期或物品交换。 更高级的非托管托管或仲裁形式也是可能的。 条件语句的复杂性没有限制，能够处理共同评估为真或假的条件组。 在条件返回 true 的情况下，这允许交易的接收者索取他们的资金或物品（取决于这是 TRANSFER 还是 DEBIT）。 如果接收方无法满足条件，在发送方设定的一段时间后，交易将可赎回。</p>
<blockquote>
  <p>在发布程序新更新时将提供更多信息。</p>
</blockquote>
<h2>API Layer 插件层</h2>
<p>API 插件层从合约（寄存器和操作层）外推。 开发人员可以轻松使用 API 插件，而不必编写 <code>smart-contract</code>&nbsp;智能合约。 尽管 API 插件层不是合约层，但它使用相同的合约层，可以通过领域特定语言 (DSL) 直接访问，以创建自定义合约。 这突出了软件堆栈的出色架构，因为相同的合约可以提供给无代码、Web 开发人员或集成到现有应用程序中，同时将它们从代码或区块链的复杂性中抽象出来。</p>
<h1>麟社上的合约</h1>
<p>Nexus 麟社设计了一种多管齐下的方法来解决 Nexus 麟社上的开发问题。 这让每个人都有机会构建和集成真正去中心化的解决方案。 下面给出了 Nexus 麟社上各种合约的详细信息</p>
<h2>Query DSL 查询领域特定语言</h2>
<p>Query DSL 查询领域特定语言是一种合约语言，增加了类似于 SQL 查询的功能，包括通配符搜索和逻辑运算符，使人们能够直接通过 API 插件搜索或过滤 Nexus 麟社上的任何数字资产或通证。 例如，可以搜索亚利桑那州的产权。 此功能为去中心化搜索引擎奠定了基础。</p>
<p>Query DSL 查询领域特定语言允许您搜索链的任何方面，您还可以过滤甚至操作查询的数据集。 支持的运算符有：min、max、mean、mode、sum、floor、array、sdev、median。 稍后将提供更多运营商。</p>
<p>Query DSL 查询领域特定语言基本上为区块链数据集提供了 SQL 功能。 运营商使其具有 Excel 功能等。 它对开发人员来说真的很强大。 它甚至可以搜索整个链：</p>
<pre><code class="language-plaintext">register/list/names where='object.name=l*' 
</code></pre>
<p>上面将显示每个以字母 l 开头的名称。 然后它可以通过过滤掉字段来运行运算符：</p>
<pre><code class="language-plaintext">register/list/names/name/array where='object.name=l*'
</code></pre>
<p>这将提供相同的数据集，但会提供一个以 “l” 开头的名称的 JSON 数组，不包括其他字段。 它还支持多个过滤器：</p>
<pre><code class="language-plaintext">register/list/names/name,owner where='object.name=l*'
</code></pre>
<p>这将响应名称和所有者字段，有点像您从名称中选择名称的 SQL 查询。 因此，它为开发人员提供了基于区块链功能的数据建模功能。</p>
<p>对整个链的全局搜索需要 1 到 2 秒。 运行得到的第一个注册命令：</p>
<p><code>[Completed in 1862.234494 ms]</code></p>
<p>有关更多信息，请查看以下链接：</p>
<ul>
  <li><a href="/en/tritium++/queries">Queries <i>A SQL like syntax query DSL</i></a></li>
  <li><a href="/en/tritium++/register">Register API <i>The Register API</i></a></li>
</ul>
<h2>Conditional Contracts 条件合约</h2>
<p>Conditional contracts are binary contract templates, users will be able to select a contract standard to send with. This will lead into dynamic allocation of contract standards and object standards per command-set. Standardization where we can allocate new contracts that will automatically populate in standards lists, without the need for a wallet upgrade.</p>
<p>What that means is we will be able to deploy new contract standards without needing to release new wallet. It will read a public sigchain that records contract and object standards. This will lead into dynamic constants as well, such as fees so that we can adjust consensus critical values without the need for hard forks or updates to the core daemon.</p>
<p>When a user sends funds using the Nexus Interface, they get an extra drop-down that allows to select from a list of standard template contracts to send under. This is a major step towards real world use of smart contracts.</p>
<h2>Conditional Contracts DSL (Future)</h2>
<p>Conditional Contracts DSL, a new standard to be written in a higher-level language and compiled into bytecode. Designed for users who will be developing new API’s or contract standards. It enables conditional contracts to be written directly into the API with the use of English, which is a crucial step in realising the full potential of Tritium’s contract functionality. This approach also allows people to be able to read or interpret contracts. This will reveal a lot of new functionality to developers.</p>
<p>We thus far have maintained the standard contracts as embedded constants in the codebase. The ability for developers to code new contracts, provides the opportunity for a dynamic standardization using Nexus to manage this state, similar to dynamic object modelling.</p>
<h2>Augmented Contracts ( Roadmap: 2023-2025)</h2>
<p>For advanced developers who need full creative control, we have developed Augmented Contacts which can be used with any domain specific language of choice. Today we have Conditional Contracts, Primitive Operators, and Registers.</p>
<p>Conditional VM will be a subset of Augmented, such as in my function I have an <code>if</code> statement, this is executed as a condition. But augmented will allow writing complex code. For instance I have an account, I do an operator overload function for <code>DEBIT</code>, that can add additional requirements for a debit from that account such as max amount per time interval, etc. I could add another public method that could be invoked by another user to draw an amount on my account if they fulfill a certain condition, so forth. It will be the full implementation of our interpreter where we will have the functionality of most languages like Java and C++.</p>
<p>Augmented Contracts are the second type of contracts that will be available in the Tritium Protocol. These types of contracts extend the Conditional VM (Virtual Machine that processes Conditional Statements) to provide additional benefits including, but not limited to, methods, functions, operation overloading, and encapsulation. Augmented contracts add a layer of complexity and processing, so will carry a higher fee to execute. This will require more on-chain processing, but overall makes our Contract Engine much more powerful.</p>
<p>The goal of Augmented Contracts is to provide relative capabilities of complex languages like C++, so we will support polymorphism, operator overloading, functions, methods, public, private, protected, unique, etc. augmented contracts builds on the existing VM- and register-based architecture. More programmable languages and things like maps, vectors, functions, etc. will come with augmented contracts.</p>
<blockquote>
  <p>More information will be provided when available.</p>
</blockquote>
