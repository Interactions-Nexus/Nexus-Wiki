<!--
title: 增强合约
description: Nexus 麟社上的增强合约
published: true
date: 2022-12-11T10:51:07.082Z
tags: 
editor: ckeditor
dateCreated: 2022-12-11T10:36:02.051Z
-->

<h1>📃 增强合约</h1>
<p>Nexus 麟社虚拟机 (NVM) 是一种 <code><strong>state machine</strong></code>状态机，作为一个单一实体存在，由数百个连接的 Nexus 麟社节点维护。</p>
<p>Nexus 麟社软件堆栈的存在仅仅是为了保持这个特殊状态机的连续、不间断和不可变的运行； 它是所有 Nexus 麟社账户和增强合约所在的环境。 在链中的任何给定点，Nexus 麟社都有一个且只有一个 <code><strong>canonical</strong></code> 规范状态，而 NVM 麟社虚拟机定义了从一个区块到另一个区块计算新有效状态的规则。</p>
<p>Even though all smart-contract platforms are state machines, the obsession to be scalable for real world usage, culminated in the distinct architecture of NVM. To easily distinguish the better architecture, it was imperative to name contracts on Nexus as Advanced contracts. Below we will unravel the architecture.</p>
<p>尽管所有智能合约平台都是状态机，但对可扩展性以适应现实世界使用的痴迷最终造就了 NVM 的独特架构。 为了轻松区分更好的架构，必须将 Nexus 麟社上的合约命名为高级合约。 下面我们将解开架构。</p>
<h2>NVM 麟社虚拟机架构</h2>
<p>NVM 麟社虚拟机被设计为“64 位元”、“register based“ 基于寄存器； 选择此设计是因为它与 CPU 中央处理器的 64 位元匹配并模仿 CPU 中央处理器缓存寄存器。</p>
<p>与 EVM 相比，这种设计使 NVM 麟社虚拟机非常快，因为它是为当今的处理器设计的。 用数字表示，EVM 需要 170 万纳秒/指令，NVM 麟社虚拟机只需要 33 纳秒/指令。 由于 EVM 在 64 位元 CPU 上的 256 位长度及其过时的堆栈设计，EVM 处于一个巨大的劣势，因为它需要 4 个周期来完成一条指令。</p>
<p>The NVM is designed intentionally not to be turing complete, this decision also stems from the fact the Nexus is a <code><strong>Verification</strong></code> engine. This design has a huge upside and that is free simple transactions, while EVM needs Gas to control computation requests due to bad contract code, which can grind the network to a halt. With the NVM design advanced contracts will have predictable fees which will be calculated before contract execution.</p>
<p>NVM 麟社虚拟机有意设计为不图灵完备，这一决定也源于 Nexus 麟社是一个 <code><strong>Verification</strong></code> 验证引擎这一事实。 这种设计有一个巨大的优势，那就是免费的简单交易，而 EVM 需要 Gas 来控制由于糟糕的合约代码而导致的计算请求，这可能会使网络陷入停顿。 使用 NVM 麟社虚拟机设计，增强合约将具有可预测的费用，这些费用将在合约执行前就可以计算出来。</p>
<p>Nexus will have different types of contracts, for the higher level API's, templates will be provided, which a user can choose from a dropdown list. For advanced users augmented contracts will empower them to use contracts with their choice of domain specific language. Augmented contracts will be available at a later date. For more details refer the <a href="https://nexus.io/roadmap">roadmap</a>.</p>
<h2>Operations &amp; Register Layers</h2>
<p>To put in a simple way, contracts are a request to perform a specific type of instruction on data which results in change in the data. In the Nexus software stack the <code>Operations layer</code> contains the instructions or actions that give registers context, and define more complex contract logic and <code>Register layer</code> is the data layer. A contract is an object containing: a register pre-state (the register that is being operated on that was passed upwards from the Register Layer), a primitive operation (only one primitive operation per contract), and a set of conditions (any amount of conditional operations).</p>
<h3>Primitive Operations</h3>
<p>The current iteration of the Operations Layer contains 16 primitive operations, and 54 conditional operations and types. The primitive operations can be best described as the actions taking place on the register such as: WRITE, DEBIT, TRANSFER, APPEND, etc. These actions themselves cause the register to change its state in some way or form, including its movement from one signature chain to another.</p>
<h3>Conditional Contracts</h3>
<p>Conditional Contracts are an agreement between participating parties, outlining a set of requirements that must be met for a transaction to complete. They are the building blocks that allow users to engage with one another, such as contract expiration, or the exchanging of items. More advanced forms of non-custodial escrow or arbitration are also possible. Conditional statements have no limit to their complexity, being capable of handling groups of groups of conditions that together evaluate to either true or false. In the case the conditions return true, this allows the recipient of the transaction to claim their funds or object (depending on if this was a TRANSFER or DEBIT). In the case that the recipient is unable to satisfy the conditions, after a period of time set by the sender, the transaction will be redeemable.</p>
<blockquote>
  <p>More information will be provided in the future when new updates are released.</p>
</blockquote>
<h2>API Layer</h2>
<p>The API layer extrapolates from the contracts (registers and operation layers). The developers can easily use the API, rather than having to code a <code>smart-contract</code>. Even though API layer is not a contract layer it uses the same contract layers which can be directly accessed by domain specific languages (DSL), to create custom contracts. This highlights the brilliant architecture of the software stack as same contracts can be made available to no-code, web developers or to integrate into existing applications, at the same time abstracting them from the complexity of code or blockchain.</p>
<h1>Contracts on Nexus</h1>
<p>Nexus has designed a multi pronged approach to tackle development on Nexus. This gives everyone an opportunity to build and integrate truly decentralized solutions. The details of the various contracts on Nexus are given below</p>
<h2>Query DSL</h2>
<p>Query DSL is one of the contract languages that adds capabilities similar to SQL query, including wildcard search and logical operators, enabling one to search or filter any digital asset or token on Nexus directly through the API. For example, one could search Property Titles in Arizona. This feature sets the foundation for a decentralized search engine.</p>
<p>The Query DSL allows you to search any aspect of the chain, you can also filter and even operate on the queried dataset. Supported operators are: <code>min, max, mean, mode, sum, floor, array, sdev, median</code>. More operators will be available at a later date.</p>
<p>Query basically gives SQL functionality over a blockchain dataset. The operators make it have Excel functionality, among others. It's really powerful for developers. It can even search the entire chain:</p>
<pre><code class="language-plaintext">register/list/names where='object.name=l*' 
</code></pre>
<p>Above will show every name that starts with the letter <code>l</code>. It can then run operators on that, by filtering out fields:</p>
<pre><code class="language-plaintext">register/list/names/name/array where='object.name=l*'
</code></pre>
<p>This will give same dataset, but give you a JSON array of the names that start with <code>'l'</code>, not including the other fields. It also supports multiple filters:</p>
<pre><code class="language-plaintext">register/list/names/name,owner where='object.name=l*'
</code></pre>
<p>This will respond with name and owner fields, somewhat like a SQL query where you do select name FROM names. So it gives a developer data modelling capabilities on top of the blockchain functionality.</p>
<p>A global search of entire chain takes 1 to 2 seconds. Running the first register command I get:</p>
<p><code>[Completed in 1862.234494 ms]</code></p>
<p>For more information, check out the link below:</p>
<ul>
  <li><a href="/en/tritium++/queries">Queries <i>A SQL like syntax query DSL</i></a></li>
  <li><a href="/en/tritium++/register">Register API <i>The Register API</i></a></li>
</ul>
<h2>Conditional Contracts</h2>
<p>Conditional contracts are binary contract templates, users will be able to select a contract standard to send with. This will lead into dynamic allocation of contract standards and object standards per command-set. Standardization where we can allocate new contracts that will automatically populate in standards lists, without the need for a wallet upgrade.</p>
<p>What that means is we will be able to deploy new contract standards without needing to release new wallet. It will read a public sigchain that records contract and object standards. This will lead into dynamic constants as well, such as fees so that we can adjust consensus critical values without the need for hard forks or updates to the core daemon.</p>
<p>When a user sends funds using the Nexus Interface, they get an extra drop-down that allows to select from a list of standard template contracts to send under. This is a major step towards real world use of smart contracts.</p>
<h2>Conditional Contracts DSL (Future)</h2>
<p>Conditional Contracts DSL, a new standard to be written in a higher-level language and compiled into bytecode. Designed for users who will be developing new API’s or contract standards. It enables conditional contracts to be written directly into the API with the use of English, which is a crucial step in realising the full potential of Tritium’s contract functionality. This approach also allows people to be able to read or interpret contracts. This will reveal a lot of new functionality to developers.</p>
<p>We thus far have maintained the standard contracts as embedded constants in the codebase. The ability for developers to code new contracts, provides the opportunity for a dynamic standardization using Nexus to manage this state, similar to dynamic object modelling.</p>
<h2>Augmented Contracts ( Roadmap: 2023-2025)</h2>
<p>For advanced developers who need full creative control, we have developed Augmented Contacts which can be used with any domain specific language of choice. Today we have Conditional Contracts, Primitive Operators, and Registers.</p>
<p>Conditional VM will be a subset of Augmented, such as in my function I have an <code>if</code> statement, this is executed as a condition. But augmented will allow writing complex code. For instance I have an account, I do an operator overload function for <code>DEBIT</code>, that can add additional requirements for a debit from that account such as max amount per time interval, etc. I could add another public method that could be invoked by another user to draw an amount on my account if they fulfill a certain condition, so forth. It will be the full implementation of our interpreter where we will have the functionality of most languages like Java and C++.</p>
<p>Augmented Contracts are the second type of contracts that will be available in the Tritium Protocol. These types of contracts extend the Conditional VM (Virtual Machine that processes Conditional Statements) to provide additional benefits including, but not limited to, methods, functions, operation overloading, and encapsulation. Augmented contracts add a layer of complexity and processing, so will carry a higher fee to execute. This will require more on-chain processing, but overall makes our Contract Engine much more powerful.</p>
<p>The goal of Augmented Contracts is to provide relative capabilities of complex languages like C++, so we will support polymorphism, operator overloading, functions, methods, public, private, protected, unique, etc. augmented contracts builds on the existing VM- and register-based architecture. More programmable languages and things like maps, vectors, functions, etc. will come with augmented contracts.</p>
<blockquote>
  <p>More information will be provided when available.</p>
</blockquote>
